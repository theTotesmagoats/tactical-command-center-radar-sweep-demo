<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tactical Radar Sweep Demo — Authenticated Naval Ops</title>
  <style>
  body {
    margin: 0;
    padding: 20px;
    background-color: #050508;
    color: #cfc;
    font-family: 'Courier New', monospace;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  
  h1 {
    margin-bottom: 10px;
    text-shadow: 0 0 8px rgba(207,255,207,0.9);
    font-size: 1.8rem;
    text-transform: uppercase;
    letter-spacing: 2px;
    border-bottom: 3px solid #cfc;
    padding-bottom: 10px;
  }

  .console-border {
    border: 4px inset #333;
    border-radius: 0;
    padding: 8px;
    background: linear-gradient(135deg, #0a0a0a 0%, #050508 100%);
    box-shadow: inset 0 0 40px rgba(0,0,0,1), 0 0 20px rgba(207,255,207,0.05);
  }

  canvas {
    display: block;
    background-color: #0a0a10;
    cursor: crosshair;
  }

  .status-bar {
    margin-top: 15px;
    font-size: 0.9rem;
    color: #afa;
    text-align: center;
  }
  
  .controls {
    display: flex;
    gap: 20px;
    margin-top: 15px;
    align-items: center;
  }

  /* Enhanced Tactical Buttons - Aircraft Carrier Style */
  button {
    background: linear-gradient(135deg, #1a1a2e 0%, #16162a 50%, #121222 100%);
    border: 3px inset #444;
    color: #cfc;
    padding: 14px 28px;
    font-family: 'Courier New', monospace;
    font-weight: bold;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 2px;
    font-size: 13px;
    transition: all 0.05s;
    box-shadow: inset 0 0 12px rgba(0,0,0,0.7), 0 2px 6px rgba(0,0,0,0.4);
    border-radius: 3px;
  }

  button:hover {
    background: linear-gradient(135deg, #2a2a3e 0%, #1a1a2e 50%, #16162a 100%);
    border-color: #666;
    box-shadow: inset 0 0 18px rgba(0,0,0,0.8), 0 3px 8px rgba(0,0,0,0.5), 0 0 12px rgba(207,255,207,0.15);
  }

  button:active {
    transform: translateY(2px);
    border: 3px outset #444;
    background: linear-gradient(135deg, #16162a 0%, #121222 50%, #0e0e1a 100%);
    box-shadow: inset 0 0 22px rgba(0,0,0,0.9), 0 0 4px rgba(207,255,207,0.05);
  }

  /* Rocker Switch Style for Toggle Buttons */
  .rocker-switch {
    display: flex;
    gap: 10px;
    margin-top: 10px;
  }

  .toggle-btn {
    width: 90px;
    height: 36px;
    background: linear-gradient(135deg, #2a1a1a 0%, #1a1414 50%, #161010 100%);
    border: 3px inset #555;
    color: #cfc;
    font-size: 10px;
    letter-spacing: 2px;
  }

  .toggle-btn.active {
    background: linear-gradient(135deg, #1a2a1a 0%, #141a14 50%, #101610 100%);
    border-color: #cfc;
    color: #cfc;
    box-shadow: inset 0 0 18px rgba(0,255,128,0.3), 0 0 12px rgba(207,255,207,0.2);
  }

  /* Tactical Controls Container */
  .sonar-controls {
    display: flex;
    gap: 20px;
    align-items: center;
    margin-top: 10px;
    flex-wrap: wrap;
    background: linear-gradient(90deg, #08080a 0%, #050508 100%);
    padding: 15px 20px;
    border-radius: 0;
    border-top: 3px solid #333;
  }

  /* Tactical Slider Container */
  .tactical-slider {
    display: flex;
    flex-direction: column;
    min-width: 240px;
    background: linear-gradient(180deg, #0a0a0c 0%, #050507 100%);
    padding: 12px;
    border-radius: 0;
    border-left: 3px solid #333;
  }

  /* Slider Labels */
  .tactical-slider label {
    font-size: 11px;
    color: #cfc;
    text-transform: uppercase;
    letter-spacing: 2px;
    margin-bottom: 8px;
  }

  /* Range and Depth Displays */
  .range-display, .depth-display {
    display: flex;
    justify-content: space-between;
    font-size: 10px;
    color: #afa;
    text-align: center;
    letter-spacing: 1px;
  }

  /* Military-Style Sliders - NO GREEN! */
  input[type=range] {
    -webkit-appearance: none;
    width: 100%;
    background: transparent;
    margin: 8px 0;
  }

  input[type=range]:focus {
    outline: none;
  }

  input[type=range]::-webkit-slider-runnable-track {
    width: 100%;
    height: 6px;
    cursor: pointer;
    background: linear-gradient(90deg, #222 0%, #444 50%, #222 100%);
    border-radius: 0;
    box-shadow: inset 0 0 8px rgba(0,0,0,0.7);
  }

  input[type=range]::-webkit-slider-thumb {
    height: 16px;
    width: 12px;
    background: linear-gradient(90deg, #555 0%, #333 50%, #444 100%);
    cursor: pointer;
    border-radius: 0;
    box-shadow: inset 0 0 8px rgba(0,0,0,0.7), 0 0 5px rgba(255,255,255,0.3);
    margin-top: -6px;
  }

  input[type=range]::-moz-range-track {
    width: 100%;
    height: 6px;
    cursor: pointer;
    background: linear-gradient(90deg, #222 0%, #444 50%, #222 100%);
    border-radius: 0;
  }

  input[type=range]::-moz-range-thumb {
    height: 16px;
    width: 12px;
    background: linear-gradient(90deg, #555 0%, #333 50%, #444 100%);
    cursor: pointer;
    border-radius: 0;
  }
  
  /* High-DPI Support */
  @media (min-resolution: 2dppx) {
    canvas {
      transform-origin: top left;
    }
  }
  </style>
</head>
<body>
  <h1>TACTICAL RADAR SWEEP (60 FPS) — PHOSPHOR GLOW ENGINE</h1>

  <div class="console-border">
    <canvas id="radarCanvas" width="800" height="600"></canvas>
  </div>

  <div class="controls">
    <button id="sonarBtn">ACTIVATE SONAR (PING)</button>
    <span>Click on radar to add contacts</span>
  </div>

  <div class="status-bar">
    FPS: <span id="fpsDisplay">60</span> | CONTACTS: <span id="contactCount">2</span> | DEPTH: 300m
  </div>

  <div class="sonar-controls">
    <div class="tactical-slider">
      <label for="rangeFilter">Range Filter (nm)</label>
      <input type="range" id="rangeFilter" min="10" max="60" value="50" step="5">
      <div class="range-display"><span id="minRangeDisplay">50</span> — <span id="maxRangeDisplay">300</span></div>
    </div>
    <button id="toggleGhostBtn" class="rocker-switch active"><span class="toggle-btn active">GHOST: ON</span></button>
  </div>

  <div class="sonar-controls">
    <div class="tactical-slider">
      <label for="depthFilter">Depth Filter (m)</label>
      <input type="range" id="depthFilter" min="0" max="500" value="300" step="10">
      <div class="depth-display"><span id="minDepthDisplay">0</span> — <span id="maxDepthDisplay">300</span></div>
    </div>
  </div>

<script>
// Setup canvas and context
const canvas = document.getElementById('radarCanvas');
const ctx = canvas.getContext('2d', { alpha: false });

// State variables
let contacts = [
  { x: 400, y: 150, speed: 0.75, angle: Math.PI / 4, depth: 50 }, // Friendly sub (green) — shallow depth
  { x: 600, y: 400, speed: 0.6, angle: -Math.PI / 3, depth: 200 }   // Enemy contact (red) — deep depth
];

// Pre-render seabed noise to offscreen canvas for performance
const preRenderNoise = document.createElement('canvas');
preRenderNoise.width = canvas.width;
preRenderNoise.height = canvas.height;
const preCtx = preRenderNoise.getContext('2d');

// Fill with dark ocean color
preCtx.fillStyle = '#0a1a2a';
preCtx.fillRect(0, 0, preRenderNoise.width, preRenderNoise.height);

// Add subtle seabed noise (sparse dots) - only once
const noiseSize = Math.floor(preRenderNoise.width * preRenderNoise.height / 500);
for (let i = 0; i < noiseSize; i++) {
  if (i % 3 === 0) { // Only draw ~1/3 of potential dots to keep it sparse
    preCtx.fillStyle = `rgba(0, 30, 60, ${Math.random() * 0.1})`;
    const x = Math.random() * preRenderNoise.width;
    const y = Math.random() * preRenderNoise.height;
    preCtx.fillRect(x, y, 2, 2);
  }
}

const MAX_BLIP_TRAIL_LENGTH = 8; // Trail length in frames
const SWEEP_SPEED = Math.PI / 320; // Rotation speed (~5.3s/cycle)
let sweepAngle = 0;
let lastTime = performance.now();
let frameCount = 0;
let fps = 60;

// Range filter settings (in nm, scale: 5px = 1nm)
let minRangeNm = 10;
let maxRangeNm = 300;

// Depth filter settings
let minDepthM = 0;
let maxDepthM = 300;

// Ghost echo toggle
let ghostEchoesEnabled = true;

// Audio context for sonar
let audioCtx = null;

function initAudio() {
  if (!audioCtx) {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContext();
  }
  // Always check state and resume if needed (handles navigation away/back)
  if (audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
}

// Play realistic sonar ping with optional bearing for spatial panning
function playSonarPing(bearingAngle, contactSpeed) {
  initAudio();
  
  const osc = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();
  
  // Realistic sonar ping: frequency sweep from 1-3 kHz down to 500 Hz (like real naval sonar)
  osc.type = 'sawtooth'; // Sawtooth gives more realistic sonar texture
  osc.frequency.setValueAtTime(2000, audioCtx.currentTime); // Start at 2kHz
  osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.4); // Sweep down to 600Hz
  
  // Create spatial effect (stereo panning)
  const panner = audioCtx.createStereoPanner();
  
  if (typeof bearingAngle !== 'undefined') {
    // Map bearing to pan: North=0°, East=90°, South=180°, West=270°
    // Pan value: -1 (left) to +1 (right), 0 = center
    panner.pan.value = Math.sin(bearingAngle);
  } else {
    // Random direction if no bearing specified (for manual ping button)
    panner.pan.value = Math.random() * 2 - 1;
  }
  
  osc.connect(panner);
  panner.connect(gainNode);
  gainNode.connect(audioCtx.destination);
  
  // Realistic sonar volume envelope
  gainNode.gain.setValueAtTime(0.4, audioCtx.currentTime); // Stronger initial hit
  gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5); // Longer fade
  
  osc.start();
  osc.stop(audioCtx.currentTime + 0.6);

  // Visual ping effect — create expanding echo ring at sweep position
  createSonarEchoRing(sweepAngle);
}

// Play realistic radar sweep "blip" sound (short sharp pulse every revolution)
function playRadarBleep() {
  if (!audioCtx) return;
  
  const osc = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();
  
  // Realistic air search radar: short high-frequency blip around 8-12 kHz
  osc.type = 'square'; // Square wave gives that classic radar blip character
  osc.frequency.setValueAtTime(9500, audioCtx.currentTime); // ~9.5kHz - typical for air search radar
  
  gainNode.gain.setValueAtTime(0.25, audioCtx.currentTime); // Sharp but not overpowering
  gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.06); // Very short decay (60ms)
  
  osc.connect(gainNode);
  gainNode.connect(audioCtx.destination);
  
  osc.start();
  osc.stop(audioCtx.currentTime + 0.08);
}

let sonarWaves = []; // Old-style concentric rings
let echoRings = [];  // New: directional echo rings from contacts
let ghostBlips = []; // Ghost echoes at previous positions

function createSonarWaveform() {
  sonarWaves.push({
    x: canvas.width / 2,
    y: canvas.height / 2,
    radius: 10,
    opacity: 0.8
  });
}

// Create echo ring for contact detection
function createSonarEchoRing(sweepAngle) {
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  
  echoRings.push({
    x: centerX + Math.cos(sweepAngle) * (canvas.width/1.8), // Ring starts near edge
    y: centerY + Math.sin(sweepAngle) * (canvas.width/1.8),
    radius: 5,
    opacity: 0.6,
    maxRadius: canvas.width / 1.2
  });
}

// Add ghost blip for contact that just passed under sweep
function addGhostBlip(contact, angleFromCenter, dist) {
  if (!ghostEchoesEnabled) return;

  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;

  // Calculate previous position based on current movement vector
  const ghostDist = Math.max(50, dist - (contact.speed * 3)); // Slightly closer than actual
  const ghostX = centerX + Math.cos(angleFromCenter) * ghostDist;
  const ghostY = centerY + Math.sin(angleFromCenter) * ghostDist;

  // FIXED: Store ghost position correctly for visual display
  ghostBlips.push({
    x: ghostX,        // Visual position (previous position)
    y: ghostY,
    actualX: contact.x, // Actual current position
    actualY: contact.y,
    opacity: 0.8,     // Increased visibility!
    age: 0,
    maxAge: 15        // Fade out after ~15 frames
  });
}

// Draw ocean background with "depth illusion"
function drawBackground() {
  // Deep ocean gradient
  const bgGradient = ctx.createRadialGradient(
    canvas.width/2, canvas.height/2, 0,
    canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)/1.5
  );
  bgGradient.addColorStop(0, "#0a1a2a");
  bgGradient.addColorStop(1, "#000000");

  ctx.fillStyle = bgGradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Use pre-rendered noise instead of recalculating every frame
  ctx.drawImage(preRenderNoise, 0, 0);

  // Grid lines (subtle tactical overlay)
  ctx.strokeStyle = "rgba(0, 255, 64, 0.1)";
  ctx.lineWidth = 1;

  const gridSize = 100;
  ctx.beginPath();
  for (let x = 0; x <= canvas.width; x += gridSize) {
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
  }
  for (let y = 0; y <= canvas.height; y += gridSize) {
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
  }
  ctx.stroke();

  // Depth rings (depth filter visualization)
  const maxRadius = Math.hypot(canvas.width/2, canvas.height/2);
  const depthScale = maxRadius / 500; // 500m maps to max radius

  for (let depth = 100; depth <= 400; depth += 100) {
    if (depth >= minDepthM && depth <= maxDepthM) {
      const r = depth * depthScale;
      ctx.strokeStyle = `rgba(0, 255, 64, ${0.1 + (depth/1000)})`;
      ctx.beginPath();
      ctx.arc(canvas.width/2, canvas.height/2, r, 0, Math.PI * 2);
      ctx.stroke();

      // Depth label
      ctx.fillStyle = "rgba(0, 255, 64, 0.3)";
      ctx.font = "10px monospace";
      ctx.textAlign = "center";
      ctx.fillText(`${depth}m`, canvas.width/2 + r - 15, canvas.height/2);
    }
  }

  // Crosshair at center
  ctx.strokeStyle = "rgba(0, 255, 64, 0.3)";
  ctx.beginPath();
  ctx.arc(canvas.width/2, canvas.height/2, 100, 0, Math.PI * 2);
  ctx.stroke();
}

// Draw contacts (blips) with trails and authentic radar behavior
function drawContacts() {
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;

  // Sweep bounds for this frame
  const trailLength = Math.PI / 6; // 30° trail
  let sweepStartAngle = sweepAngle - trailLength;
  let sweepEndAngle = sweepAngle;

  contacts.forEach((contact, i) => {
    // Initialize properties if not present (FIXED: check both properties independently)
    contact.lastInSweep = (typeof contact.lastInSweep === 'undefined') ? false : contact.lastInSweep;
    contact.undetectedFrames = (typeof contact.undetectedFrames === 'undefined') ? 0 : contact.undetectedFrames;
    // Initialize depth if not present
    contact.depth = (typeof contact.depth === 'undefined') ? 150 : contact.depth;

    // Record current position for trail
    if (!contact.trail) contact.trail = [];
    contact.trail.push({ x: contact.x, y: contact.y });
    if (contact.trail.length > MAX_BLIP_TRAIL_LENGTH) contact.trail.shift();

    // Move contact with realistic speed based on type:
    // Subsurface (GOBLIN): depth > 50m → slow movement (2-15 knots)
    // Surface (SKUNK): depth ≤ 50m → medium movement (5-30 knots)
    
    let currentSpeed = contact.speed;
    if (contact.depth > 50) {
      // Subsurface contacts move slowly (like real submarines)
      // 0.3-2.0 px/frame = ~6-40 knots
      currentSpeed = Math.max(0.3, Math.min(2.0, contact.speed));
    } else {
      // Surface contacts move at ship speeds
      // 0.8-4.0 px/frame = ~16-80 knots
      currentSpeed = Math.max(0.8, Math.min(4.0, contact.speed));
    }

    contact.x += Math.cos(contact.angle) * currentSpeed;
    contact.y += Math.sin(contact.angle) * currentSpeed;

    // Wrap around screen edges (toroidal space)
    if (contact.x < 0) contact.x = canvas.width;
    if (contact.x > canvas.width) contact.x = 0;
    if (contact.y < 0) contact.y = canvas.height;
    if (contact.y > canvas.height) contact.y = 0;

    // Draw trail
    for (let j = 0; j < contact.trail.length; j++) {
      const pos = contact.trail[j];
      const alpha = (j / contact.trail.length) * 0.4; // Fade from center to end

      ctx.fillStyle = i === 0 ? `rgba(0,255,64,${alpha})` : `rgba(255,0,0,${alpha})`;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, 2, 0, Math.PI * 2);
      ctx.fill();
    }

    // Calculate distance from center (in pixels)
    const dx = contact.x - centerX;
    const dy = contact.y - centerY;
    const distPx = Math.sqrt(dx*dx + dy*dy);
    const distNm = distPx / 5; // Scale: 5px = 1nm

    // Range filter check
    if (distNm < minRangeNm || distNm > maxRangeNm) {
      return; // Skip contacts outside range filter
    }

    // Depth filter check
    const contactDepth = contact.depth;
    if (contactDepth < minDepthM || contactDepth > maxDepthM) {
      return; // Skip contacts outside depth filter
    }

    // Calculate bearing (angle from center)
    let angleFromCenter = Math.atan2(dy, dx);
    if (angleFromCenter < 0) angleFromCenter += Math.PI * 2;

    // Determine if contact is within current sweep arc — FIXED to match actual sweep bounds
    let inSweep = false;
    
    // Normalize angles consistently for comparison
    const normalizedAngle = angleFromCenter % (Math.PI * 2);
    const normalizedStart = sweepStartAngle % (Math.PI * 2);
    const normalizedEnd = sweepEndAngle % (Math.PI * 2);
    
    if (normalizedStart <= normalizedEnd) {
      // Normal arc (no wrap around 0°)
      inSweep = normalizedAngle >= normalizedStart && normalizedAngle <= normalizedEnd;
    } else {
      // Arc crosses 0° boundary — split into two ranges
      inSweep = normalizedAngle >= normalizedStart || normalizedAngle <= normalizedEnd;
    }

    // Sonar ping only when sweep *first* reaches contact (transition from !inSweep to inSweep)
    if (!contact.lastInSweep && inSweep) {
      // Convert radar bearing to pan value for spatial audio
      const bearingFromNorth = (Math.PI / 2 - angleFromCenter + Math.PI * 2) % (Math.PI * 2);

      // Add ghost blip when contact is first detected
      addGhostBlip(contact, angleFromCenter, distPx);

      playSonarPing(bearingFromNorth, currentSpeed);
    }

    // Update lastInSweep state
    contact.lastInSweep = inSweep;

    // Handle fade-out if not detected for several sweeps
    if (!inSweep) {
      contact.undetectedFrames++;
    } else {
      contact.undetectedFrames = 0;
    }

    // Calculate signal strength based on proximity to sweep center (0=strong, 1=weak)
    const angleDiff1 = Math.abs(angleFromCenter - sweepAngle);
    const angleDiff2 = Math.abs(angleFromCenter - (sweepAngle + Math.PI * 2));
    const angleDiff3 = Math.abs((angleFromCenter + Math.PI * 2) - sweepAngle);
    const minAngleDiff = Math.min(angleDiff1, angleDiff2, angleDiff3);
    
    // Normalize: 0 at center of sweep, 1 at edges
    const signalStrength = Math.min(minAngleDiff / (trailLength/2), 1);

    // Fade out if undetected for too long
    let contactAlpha = 1;
    if (contact.undetectedFrames > 5) {
      contactAlpha = Math.max(0, 1 - (contact.undetectedFrames - 5) * 0.2);
    }

    // Draw contact blip with signal strength and fade
    ctx.shadowBlur = inSweep ? 8 : 0;
    ctx.shadowColor = i === 0 ? "#0f0" : "#f00";

    const baseColor = i === 0 ? "rgba(0,255,64," : "rgba(255,0,0,";
    // Signal strength affects glow: stronger when closer to sweep center
    ctx.fillStyle = baseColor + (contactAlpha * (1 - signalStrength * 0.3)) + ")";

    // Contact size varies slightly with signal strength
    const blipSize = inSweep ? 4 : Math.max(2, 3 - signalStrength);

    ctx.beginPath();
    ctx.arc(contact.x, contact.y, blipSize, 0, Math.PI * 2);
    ctx.fill();

    // Label (distance and bearing) — only show when under sweep or friendly
    if (inSweep || i === 0) {
      ctx.fillStyle = `rgba(207, 255, 207, ${contactAlpha})`;
      ctx.font = "10px monospace";
      const rangeNm = Math.round(distPx / 5);
      const bearingDeg = Math.round(angleFromCenter * (180/Math.PI));

      // Add depth info to label
      const depthInfo = contactDepth > 0 ? ` D:${contactDepth}m` : '';
      ctx.fillText(`BLIP-${i+1} R:${rangeNm}nm B:${bearingDeg}${depthInfo}`, contact.x + 10, contact.y - 8);
    }

    ctx.shadowBlur = 0;
  });

  // Draw ghost blips (delayed echoes) — CLEANED UP TEXT!
  for (let i = ghostBlips.length - 1; i >= 0; i--) {
    const ghost = ghostBlips[i];
    ghost.age++;
    ghost.opacity -= 0.04;

    if (ghost.opacity <= 0 || ghost.age > ghost.maxAge) {
      ghostBlips.splice(i, 1);
      continue;
    }

    // FIXED: Draw ghost blip at previous position (visual ghost location)
    ctx.fillStyle = `rgba(255, 255, 255, ${ghost.opacity})`;
    ctx.beginPath();
    ctx.arc(ghost.x, ghost.y, 4, 0, Math.PI * 2); // Draw at actual ghost position
    ctx.fill();

    // Draw line connecting to actual position — THICKER!
    ctx.strokeStyle = `rgba(255, 255, 255, ${ghost.opacity})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(ghost.x, ghost.y);
    ctx.lineTo(ghost.actualX, ghost.actualY); // Line to actual position
    ctx.stroke();

    // REMOVED: Ghost text labels to prevent visual "glitching"
    // Ghost echoes are visual aids — no need for detailed labels that clutter the display
  }
}

// Draw radar sweep — single wedge with gradient and sharp leading edge
function drawRadarSweep() {
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  const radius = Math.hypot(centerX, centerY); // Half-diagonal → reaches all corners

  ctx.globalCompositeOperation = 'lighter';

  // Single sweep wedge — shorter trail for sharper look
  const trailLength = Math.PI / 6; // 30° trail (was 60°)
  let startAngle = sweepAngle - trailLength;
  const endAngle = sweepAngle;

  if (startAngle < 0) {
    // Arc crosses top — draw in two parts
    ctx.beginPath();
    ctx.moveTo(centerX, centerY);
    ctx.arc(centerX, centerY, radius, startAngle + Math.PI * 2, Math.PI * 2);
    ctx.arc(centerX, centerY, radius, 0, endAngle);
  } else if (endAngle > Math.PI * 2) {
    // Arc crosses bottom — draw in two parts
    ctx.beginPath();
    ctx.moveTo(centerX, centerY);
    ctx.arc(centerX, centerY, radius, startAngle, Math.PI * 2);
    ctx.arc(centerX, centerY, radius, 0, endAngle - Math.PI * 2);
  } else {
    // Normal arc (no wrap)
    ctx.beginPath();
    ctx.moveTo(centerX, centerY);
    ctx.arc(centerX, centerY, radius, startAngle, endAngle);
  }

  ctx.closePath();

  // Radial gradient for glow falloff
  const grad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
  grad.addColorStop(0, 'rgba(0, 255, 64, 0)');     // transparent at center
  grad.addColorStop(0.3, 'rgba(0, 255, 64, 0.15)'); // mid-fade
  grad.addColorStop(1, 'rgba(0, 255, 64, 0.25)');   // faint edge

  ctx.fillStyle = grad;
  ctx.fill();

  // Bright leading edge line with optimized glow
  ctx.beginPath();
  ctx.moveTo(centerX, centerY);
  ctx.lineTo(
    centerX + Math.cos(sweepAngle) * radius,
    centerY + Math.sin(sweepAngle) * radius
  );
  ctx.strokeStyle = 'rgba(0, 255, 64, 1.0)'; // Brighter line (was 0.9)
  ctx.lineWidth = 2;
  ctx.shadowBlur = 8; // Reduced from 12 for tighter glow
  ctx.shadowColor = '#0f0';
  ctx.stroke();
  ctx.shadowBlur = 0;

  ctx.globalCompositeOperation = 'source-over';

  // Update sweep angle for next frame
  sweepAngle += SWEEP_SPEED;
  
  // Normalize sweep angle to keep it bounded (prevents floating point accumulation)
  if (sweepAngle >= Math.PI * 2) {
    sweepAngle -= Math.PI * 2;
  }
  
  // Play radar bleep when sweep completes a full revolution (~5.3 seconds)
  // Check with small tolerance for the threshold
  if (sweepAngle < SWEEP_SPEED && sweepAngle > 0) { // Just wrapped around
    playRadarBleep(); // Add the "bleep" sound every revolution
  }

  // Draw sonar waveforms if active
  for (let i = sonarWaves.length - 1; i >= 0; i--) {
    const wave = sonarWaves[i];
    // Expand and fade
    wave.radius += 3;
    wave.opacity -= 0.02;

    if (wave.opacity <= 0) {
      sonarWaves.splice(i, 1);
      continue;
    }

    ctx.beginPath();
    ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(0, 255, 64, ${wave.opacity})`;
    ctx.lineWidth = 2;
    ctx.stroke();

    // Add "ping" text at interval
    if (Math.floor(Date.now() / 100) % 3 === 0) {
      ctx.fillStyle = `rgba(255, 255, 255, ${wave.opacity})`;
      ctx.font = "bold 14px monospace";
      ctx.fillText("PING!", wave.x - 18, wave.y + 4);
    }
  }

  // Draw echo rings from contact detections
  for (let i = echoRings.length - 1; i >= 0; i--) {
    const ring = echoRings[i];
    // Expand and fade
    ring.radius += 8;
    ring.opacity -= 0.05;

    if (ring.opacity <= 0 || ring.radius > ring.maxRadius) {
      echoRings.splice(i, 1);
      continue;
    }

    ctx.beginPath();
    ctx.arc(ring.x, ring.y, ring.radius, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(0, 255, 64, ${ring.opacity})`;
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Add echo indicator text
    if (Math.floor(Date.now() / 50) % 4 === 0) {
      ctx.fillStyle = `rgba(255, 255, 255, ${ring.opacity})`;
      ctx.font = "10px monospace";
      const rangeNm = Math.round(ring.radius / 8); // Approximate scale
      ctx.fillText(`ECHO ${rangeNm}nm`, ring.x - 15, ring.y + 3);
    }
  }

  // Draw center hub
  ctx.fillStyle = "#0a3a0a";
  ctx.beginPath();
  ctx.arc(centerX, centerY, 25, 0, Math.PI * 2);
  ctx.fill();

  // Crosshair lines
  ctx.strokeStyle = "rgba(0, 255, 64, 0.3)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(centerX - 30, centerY);
  ctx.lineTo(centerX + 30, centerY);
  ctx.moveTo(centerX, centerY - 30);
  ctx.lineTo(centerX, centerY + 30);
  ctx.stroke();

  // Range rings with labels (nautical miles)
  for (let r = 150; r < radius; r += 150) {
    const nm = Math.round(r / 5); // Scale: 5px = 1nm

    ctx.strokeStyle = "rgba(0, 255, 64, 0.15)";
    ctx.beginPath();
    ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
    ctx.stroke();

    // Label on the ring
    ctx.fillStyle = "#afa";
    ctx.font = "bold 12px monospace";
    ctx.textAlign = "center";
    ctx.fillText(`${nm}nm`, centerX + r - 15, centerY - 3);
  }

  // Direction indicator (N)
  ctx.fillStyle = "#afa";
  ctx.font = "bold 14px monospace";
  ctx.textAlign = "left";
  ctx.fillText("N", centerX + 5, centerY - radius + 15);
}

// Main render loop
function animate() {
  const now = performance.now();
  frameCount++;

  if (now - lastTime >= 1000) {
    fps = Math.round((frameCount * 1000) / (now - lastTime));
    document.getElementById('fpsDisplay').innerText = fps;
    // Update contact count
    document.getElementById('contactCount').innerText = contacts.length;
    frameCount = 0;
    lastTime = now;
  }

  // Clear canvas with slight fade for motion blur effect
  ctx.fillStyle = "rgba(10, 26, 42, 0.3)"; // Very slight trail
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  drawBackground();
  drawContacts();
  drawRadarSweep();

  requestAnimationFrame(animate);
}

// Click to add new contacts (e.g., detected by sonar)
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  // Create a random contact with realistic speed based on depth type:
  // Subsurface: slow movement (0.3-2.0 px/frame)
  // Surface: medium movement (0.8-4.0 px/frame)
  const angle = Math.random() * Math.PI * 2;
  const depth = Math.floor(Math.random() * 400) + 50; // 50-450m

  let speed;
  if (depth > 50) {
    // Subsurface contacts move slowly
    speed = 0.3 + Math.random() * 1.7; // 0.3-2.0 px/frame
  } else {
    // Surface contacts move at ship speeds
    speed = 0.8 + Math.random() * 3.2; // 0.8-4.0 px/frame
  }

  contacts.push({
    x,
    y,
    speed: speed, // Realistic variable speed based on type
    angle,
    depth
  });
});

// Sonar button handler
document.getElementById('sonarBtn').addEventListener('click', () => {
  playSonarPing(); // Random direction for manual ping
  // Flash the screen slightly to simulate active sonar pulse
  const flash = document.createElement('div');
  flash.style.position = 'fixed';
  flash.style.top = '0';
  flash.style.left = '0';
  flash.style.width = '100%';
  flash.style.height = '100%';
  flash.style.backgroundColor = 'rgba(207, 255, 207, 0.1)';
  flash.style.pointerEvents = 'none';
  flash.style.transition = 'opacity 0.3s';
  document.body.appendChild(flash);

  setTimeout(() => {
    flash.style.opacity = '0';
    setTimeout(() => {
      document.body.removeChild(flash);
    }, 300);
  }, 50);
});

// Range filter slider handler
const rangeSlider = document.getElementById('rangeFilter');
const minRangeDisplay = document.getElementById('minRangeDisplay');
const maxRangeDisplay = document.getElementById('maxRangeDisplay');

rangeSlider.addEventListener('input', () => {
  const value = parseInt(rangeSlider.value);
  minRangeNm = value;
  maxRangeNm = value * 6; // Max range is 6x the min (50-300nm at default)

  minRangeDisplay.textContent = minRangeNm;
  maxRangeDisplay.textContent = maxRangeNm;
});

// Depth filter slider handler
const depthSlider = document.getElementById('depthFilter');
const minDepthDisplay = document.getElementById('minDepthDisplay');
const maxDepthDisplay = document.getElementById('maxDepthDisplay');

depthSlider.addEventListener('input', () => {
  const value = parseInt(depthSlider.value);
  minDepthM = 0;
  maxDepthM = value; // Filter shows contacts shallower than this depth

  minDepthDisplay.textContent = minDepthM;
  maxDepthDisplay.textContent = maxDepthM;
});

// Ghost echo toggle button — ENHANCED VISUAL FEEDBACK!
const ghostBtnContainer = document.getElementById('toggleGhostBtn');

ghostBtnContainer.addEventListener('click', () => {
  ghostEchoesEnabled = !ghostEchoesEnabled;

  // Update button styling
  const toggleBtn = ghostBtnContainer.querySelector('.toggle-btn');
  if (ghostEchoesEnabled) {
    toggleBtn.textContent = 'GHOST: ON';
    toggleBtn.classList.add('active');
  } else {
    toggleBtn.textContent = 'GHOST: OFF';
    toggleBtn.classList.remove('active');
  }

  if (!ghostEchoesEnabled) {
    // Clear existing ghosts and show confirmation
    ghostBlips = [];
    console.log("Ghost echoes OFF — cleared");
  } else {
    // Spawn a test ghost to prove it's working!
    const testContact = { x: canvas.width/2 + 100, y: canvas.height/2, speed: 0.75, angle: Math.PI/4 };
    addGhostBlip(testContact, Math.PI/4, Math.hypot(100, 0));
    console.log("Ghost echoes ON — test ghost spawned");
  }

  // Visual button feedback
  setTimeout(() => {
    toggleBtn.style.boxShadow = ghostEchoesEnabled ? "inset 0 0 25px rgba(207,255,207,0.4), 0 0 15px rgba(207,255,207,0.4)" : "inset 0 0 25px rgba(255,0,0,0.4), 0 0 15px rgba(255,0,0,0.4)";
    setTimeout(() => {
      toggleBtn.style.boxShadow = ghostEchoesEnabled ? "inset 0 0 15px rgba(207,255,207,0.3), 0 0 10px rgba(207,255,207,0.3)" : "none";
    }, 100);
  }, 100);
});

// Start the animation
animate();
</script>
</body>
</html>
