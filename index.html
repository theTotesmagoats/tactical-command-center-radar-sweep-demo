<!DOCTYPE html>
<html lang="en">
<head>  
  <meta charset="UTF-8">  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">  
  <title>Tactical Radar Sweep Demo — Authenticated Naval Ops</title>  
  <style>  
    body {  
      margin: 0;  
      padding: 20px;  
      background-color: #0a0a10;  
      color: #0f0;  
      font-family: 'Courier New', monospace;  
      display: flex;  
      flex-direction: column;  
      align-items: center;  
    }      
    h1 {  
      margin-bottom: 10px;  
      text-shadow: 0 0 5px rgba(0,255,0,0.7);  
      font-size: 1.8rem;  
    }  

    .console-border {  
      border: 4px solid #333;  
      border-radius: 12px;  
      padding: 8px;  
      background: #000;  
      box-shadow: inset 0 0 30px rgba(0,0,0,0.9), 0 0 15px rgba(0,255,0,0.1);  
    }      
    
    canvas {  
      display: block;  
      background-color: #0a0a10;  
      cursor: crosshair;  
    }

    .status-bar {  
      margin-top: 15px;  
      font-size: 0.9rem;  
      color: #888;  
      text-align: center;  
    }      
    
    .controls {  
      display: flex;  
      gap: 20px;  
      margin-top: 15px;  
      align-items: center;  
    }

    button {  
      background: rgba(0, 30, 0, 0.7);  
      border: 2px solid #0f0;  
      color: #0f0;  
      padding: 8px 20px;  
      font-family: 'Courier New', monospace;  
      font-weight: bold;  
      cursor: pointer;  
      text-transform: uppercase;  
      transition: all 0.1s;  
    }

    button:hover {  
      background: rgba(0, 50, 0, 0.8);  
      box-shadow: 0 0 10px #0f0;  
    }

    button:active {  
      transform: scale(0.97);  
      background: #0f0;  
      color: #000;  
    }  
  </style>
</head>  
<body>  
  <h1>TACTICAL RADAR SWEEP (60 FPS) — PHOSPHOR GLOW ENGINE</h1>

  <div class="console-border">  
    <canvas id="radarCanvas" width="800" height="600"></canvas>  
  </div>

  <div class="controls">  
    <button id="sonarBtn">ACTIVATE SONAR (PING)</button>  
    <span>Click on radar to add contacts</span>  
  </div>

  <div class="status-bar">  
    FPS: <span id="fpsDisplay">60</span> | CONTACTS: <span id="contactCount">2</span> | DEPTH: 300m  
  </div>  

  <script>  
    // Setup canvas and context  
    const canvas = document.getElementById('radarCanvas');  
    const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no transparency on base  
      
    // State variables  
    let contacts = [  
      { x: 400, y: 150, speed: 0.75, angle: Math.PI / 4 }, // Friendly sub (green) — slower speed  
      { x: 600, y: 400, speed: 0.6, angle: -Math.PI / 3 }  // Enemy contact (red) — slower speed  
    ];  
      
    let blipTrails = []; // Store recent positions for trails  
    const MAX_BLIP_TRAIL_LENGTH = 8; // Trail length in frames  
    const SWEEP_SPEED = Math.PI / 320; // Rotation speed (~5.3s/cycle)  
    let sweepAngle = 0;  
    let lastTime = performance.now();  
    let frameCount = 0;  
    let fps = 60;  

    // Audio context for sonar  
    let audioCtx = null;  

    function initAudio() {  
      if (!audioCtx) {  
        const AudioContext = window.AudioContext || window.webkitAudioContext;  
        audioCtx = new AudioContext();  
      }  
      if (audioCtx.state === 'suspended') {  
        audioCtx.resume();  
      }  
    }  

    // Play realistic sonar ping with optional bearing for spatial panning  
    function playSonarPing(bearingAngle) {  
      initAudio();  
      
      const osc = audioCtx.createOscillator();  
      const gainNode = audioCtx.createGain();  
      
      osc.type = 'sine';  
      osc.frequency.setValueAtTime(200, audioCtx.currentTime);  
      osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);  
      
      // Create spatial effect (stereo panning)  
      const panner = audioCtx.createStereoPanner();  
      
      if (typeof bearingAngle !== 'undefined') {  
        // Map bearing to pan: North=0°, East=90°, South=180°, West=270°  
        // Pan value: -1 (left) to +1 (right), 0 = center  
        panner.pan.value = Math.sin(bearingAngle);  
      } else {  
        // Random direction if no bearing specified (for manual ping button)  
        panner.pan.value = Math.random() * 2 - 1;  
      }
      
      osc.connect(panner);  
      panner.connect(gainNode);  
      gainNode.connect(audioCtx.destination);  
      
      gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);  
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);  
      
      osc.start();  
      osc.stop(audioCtx.currentTime + 0.6);

      // Visual ping effect  
      createSonarWaveform();
    }  

    let sonarWaves = [];  

    function createSonarWaveform() {  
      sonarWaves.push({  
        x: canvas.width / 2,  
        y: canvas.height / 2,  
        radius: 10,  
        opacity: 0.8  
      });  
    }  

    // Draw ocean background with "depth illusion"  
    function drawBackground() {  
      // Deep ocean gradient  
      const bgGradient = ctx.createRadialGradient(  
        canvas.width/2, canvas.height/2, 0,  
        canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)/1.5  
      );  
      bgGradient.addColorStop(0, "#0a1a2a");  
      bgGradient.addColorStop(1, "#000000");  
      
      ctx.fillStyle = bgGradient;  
      ctx.fillRect(0, 0, canvas.width, canvas.height);  
      
      // Subtle seabed noise (sparse dots)  
      const noiseSize = Math.floor(canvas.width * canvas.height / 500);  
      for (let i = 0; i < noiseSize; i++) {  
        if (i % 3 === 0) { // Only draw ~1/3 of potential dots to keep it sparse  
          ctx.fillStyle = `rgba(0, 30, 60, ${Math.random() * 0.1})`;  
          const x = Math.random() * canvas.width;  
          const y = Math.random() * canvas.height;  
          ctx.fillRect(x, y, 2, 2);  
        }  
      }

      // Grid lines (subtle tactical overlay)  
      ctx.strokeStyle = "rgba(0, 255, 64, 0.1)";  
      ctx.lineWidth = 1;  
      
      const gridSize = 100;  
      ctx.beginPath();  
      for (let x = 0; x <= canvas.width; x += gridSize) {  
        ctx.moveTo(x, 0);  
        ctx.lineTo(x, canvas.height);  
      }  
      for (let y = 0; y <= canvas.height; y += gridSize) {  
        ctx.moveTo(0, y);  
        ctx.lineTo(canvas.width, y);  
      }  
      ctx.stroke();  

      // Crosshair at center  
      ctx.strokeStyle = "rgba(0, 255, 64, 0.3)";  
      ctx.beginPath();  
      ctx.arc(canvas.width/2, canvas.height/2, 100, 0, Math.PI * 2);  
      ctx.stroke();  
    }  

    // Draw contacts (blips) with trails and authentic radar behavior  
    function drawContacts() {  
      const centerX = canvas.width / 2;  
      const centerY = canvas.height / 2;

      // Sweep bounds for this frame  
      const trailLength = Math.PI / 6; // 30° trail  
      let sweepStartAngle = sweepAngle - trailLength;
      let sweepEndAngle = sweepAngle;

      contacts.forEach((contact, i) => {  
        // Initialize lastInSweep if not present  
        if (typeof contact.lastInSweep === 'undefined') {
          contact.lastInSweep = false;
        }

        // Record current position for trail  
        if (!contact.trail) contact.trail = [];  
        contact.trail.push({ x: contact.x, y: contact.y });  
        if (contact.trail.length > MAX_BLIP_TRAIL_LENGTH) contact.trail.shift();

        // Move contact  
        contact.x += Math.cos(contact.angle) * contact.speed;  
        contact.y += Math.sin(contact.angle) * contact.speed;  
        
        // Wrap around screen edges (toroidal space)  
        if (contact.x < 0) contact.x = canvas.width;  
        if (contact.x > canvas.width) contact.x = 0;  
        if (contact.y < 0) contact.y = canvas.height;  
        if (contact.y > canvas.height) contact.y = 0;

        // Draw trail  
        for (let j = 0; j < contact.trail.length; j++) {  
          const pos = contact.trail[j];  
          const alpha = (j / contact.trail.length) * 0.4; // Fade from center to end  
          
          ctx.fillStyle = i === 0 ? `rgba(0,255,0,${alpha})` : `rgba(255,0,0,${alpha})`;  
          ctx.beginPath();  
          ctx.arc(pos.x, pos.y, 2, 0, Math.PI * 2);  
          ctx.fill();  
        }

        // Calculate distance from center  
        const dx = contact.x - centerX;  
        const dy = contact.y - centerY;  
        const dist = Math.sqrt(dx*dx + dy*dy);  
        
        // Calculate bearing (angle from center)  
        let angleFromCenter = Math.atan2(dy, dx);  
        if (angleFromCenter < 0) angleFromCenter += Math.PI * 2;

        // Determine if contact is within current sweep arc — FIXED to match actual sweep bounds  
        let inSweep = false;
        
        // Normalize sweep angles to [0, 2π)  
        while (sweepStartAngle < 0) sweepStartAngle += Math.PI * 2;
        while (sweepEndAngle > Math.PI * 2) sweepEndAngle -= Math.PI * 2;

        if (sweepStartAngle <= sweepEndAngle) {  
          // Normal arc (no wrap around 0°)  
          inSweep = angleFromCenter >= sweepStartAngle && angleFromCenter <= sweepEndAngle;  
        } else {  
          // Arc crosses 0° boundary — split into two ranges  
          inSweep = angleFromCenter >= sweepStartAngle || angleFromCenter <= sweepEndAngle;  
        }

        // Sonar ping only when sweep *first* reaches contact (transition from !inSweep to inSweep)  
        if (!contact.lastInSweep && inSweep) {  
          // Convert radar bearing to pan value for spatial audio  
          const bearingFromNorth = (Math.PI / 2 - angleFromCenter + Math.PI * 2) % (Math.PI * 2);
          playSonarPing(bearingFromNorth);
        }

        // Update lastInSweep state  
        contact.lastInSweep = inSweep;

        // Draw contact blip (only glow when under the actual sweep)  
        ctx.shadowBlur = inSweep ? 8 : 0;  
        ctx.shadowColor = i === 0 ? "#0f0" : "#f00";  
        
        const color = i === 0 ? "rgba(0,255,0,1)" : "rgba(255,0,0,0.7)";  
        ctx.fillStyle = color;  
        
        ctx.beginPath();  
        ctx.arc(contact.x, contact.y, inSweep ? 4 : 3, 0, Math.PI * 2);  
        ctx.fill();

        // Label (distance and bearing) — only show when under sweep or friendly  
        if (inSweep || i === 0) {  
          ctx.fillStyle = "#8f8";  
          ctx.font = "10px monospace";  
          const rangeNm = Math.round(dist / 5);  
          const bearingDeg = Math.round(angleFromCenter * (180/Math.PI));  
          
          ctx.fillText(`BLIP-${i+1} R:${rangeNm} B:${bearingDeg}`, contact.x + 10, contact.y - 8);  
        }

        ctx.shadowBlur = 0;  
      });  
    }  

    // Draw radar sweep — single wedge with gradient and sharp leading edge  
    function drawRadarSweep() {  
      const centerX = canvas.width / 2;  
      const centerY = canvas.height / 2;  
      const radius = Math.hypot(centerX, centerY); // Half-diagonal → reaches all corners  

      ctx.globalCompositeOperation = 'lighter';

      // Single sweep wedge — shorter trail for sharper look  
      const trailLength = Math.PI / 6; // 30° trail (was 60°)  
      let startAngle = sweepAngle - trailLength;
      const endAngle = sweepAngle;

      if (startAngle < 0) {  
        // Arc crosses top — draw in two parts  
        ctx.beginPath();  
        ctx.moveTo(centerX, centerY);  
        ctx.arc(centerX, centerY, radius, startAngle + Math.PI * 2, Math.PI * 2);  
        ctx.arc(centerX, centerY, radius, 0, endAngle);  
      } else if (endAngle > Math.PI * 2) {  
        // Arc crosses bottom — draw in two parts  
        ctx.beginPath();  
        ctx.moveTo(centerX, centerY);  
        ctx.arc(centerX, centerY, radius, startAngle, Math.PI * 2);  
        ctx.arc(centerX, centerY, radius, 0, endAngle - Math.PI * 2);  
      } else {  
        // Normal arc (no wrap)  
        ctx.beginPath();  
        ctx.moveTo(centerX, centerY);  
        ctx.arc(centerX, centerY, radius, startAngle, endAngle);  
      }
      
      ctx.closePath();

      // Radial gradient for glow falloff  
      const grad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
      grad.addColorStop(0, 'rgba(0, 255, 0, 0)');     // transparent at center  
      grad.addColorStop(0.3, 'rgba(0, 255, 0, 0.15)'); // mid-fade  
      grad.addColorStop(1, 'rgba(0, 255, 0, 0.25)');   // faint edge  

      ctx.fillStyle = grad;  
      ctx.fill();

      // Bright leading edge line with optimized glow  
      ctx.beginPath();  
      ctx.moveTo(centerX, centerY);  
      ctx.lineTo(
        centerX + Math.cos(sweepAngle) * radius,
        centerY + Math.sin(sweepAngle) * radius
      );
      ctx.strokeStyle = 'rgba(0, 255, 100, 1.0)'; // Brighter line (was 0.9)
      ctx.lineWidth = 2;
      ctx.shadowBlur = 8; // Reduced from 12 for tighter glow  
      ctx.shadowColor = '#0f0';
      ctx.stroke();
      ctx.shadowBlur = 0;

      ctx.globalCompositeOperation = 'source-over';

      // Update sweep angle for next frame  
      sweepAngle += SWEEP_SPEED;  
      if (sweepAngle >= Math.PI * 2) {  
        sweepAngle -= Math.PI * 2;  
      }

      // Draw sonar waveforms if active  
      for (let i = sonarWaves.length - 1; i >= 0; i--) {  
        const wave = sonarWaves[i];  
        
        // Expand and fade  
        wave.radius += 3;  
        wave.opacity -= 0.02;

        if (wave.opacity <= 0) {  
          sonarWaves.splice(i, 1);  
          continue;  
        }

        ctx.beginPath();  
        ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);  
        ctx.strokeStyle = `rgba(0, 255, 255, ${wave.opacity})`;  
        ctx.lineWidth = 2;  
        ctx.stroke();

        // Add "ping" text at interval  
        if (Math.floor(Date.now() / 100) % 3 === 0) {  
          ctx.fillStyle = `rgba(255, 255, 255, ${wave.opacity})`;  
          ctx.font = "bold 14px monospace";  
          ctx.fillText("PING!", wave.x - 18, wave.y + 4);  
        }  
      }

      // Draw center hub  
      ctx.fillStyle = "#0a3a0a";  
      ctx.beginPath();  
      ctx.arc(centerX, centerY, 25, 0, Math.PI * 2);  
      ctx.fill();

      // Crosshair lines  
      ctx.strokeStyle = "rgba(0, 255, 64, 0.3)";  
      ctx.lineWidth = 1;  
      ctx.beginPath();  
      ctx.moveTo(centerX - 30, centerY);  
      ctx.lineTo(centerX + 30, centerY);  
      ctx.moveTo(centerX, centerY - 30);  
      ctx.lineTo(centerX, centerY + 30);  
      ctx.stroke();

      // Range rings with labels (nautical miles)  
      for (let r = 150; r < radius; r += 150) {  
        const nm = Math.round(r / 5); // Scale: 5px = 1nm  
        
        ctx.strokeStyle = "rgba(0, 255, 64, 0.15)";  
        ctx.beginPath();  
        ctx.arc(centerX, centerY, r, 0, Math.PI * 2);  
        ctx.stroke();

        // Label on the ring  
        ctx.fillStyle = "#8f8";  
        ctx.font = "bold 12px monospace";  
        ctx.textAlign = "center";  
        ctx.fillText(`${nm}nm`, centerX + r - 15, centerY - 3);  
      }

      // Direction indicator (N)  
      ctx.fillStyle = "#8f8";  
      ctx.font = "bold 14px monospace";  
      ctx.textAlign = "left";  
      ctx.fillText("N", centerX + 5, centerY - radius + 15);  
    }  

    // Main render loop  
    function animate() {  
      const now = performance.now();  
      frameCount++;  
      
      if (now - lastTime >= 1000) {  
        fps = Math.round((frameCount * 1000) / (now - lastTime));  
        document.getElementById('fpsDisplay').innerText = fps;  
        
        // Update contact count  
        document.getElementById('contactCount').innerText = contacts.length;  
        
        frameCount = 0;  
        lastTime = now;  
      }

      // Clear canvas with slight fade for motion blur effect  
      ctx.fillStyle = "rgba(10, 26, 42, 0.3)"; // Very slight trail  
      ctx.fillRect(0, 0, canvas.width, canvas.height);  
      
      drawBackground();  
      drawContacts();  
      drawRadarSweep();

      requestAnimationFrame(animate);  
    }  

    // Click to add new contacts (e.g., detected by sonar)  
    canvas.addEventListener('click', (e) => {  
      const rect = canvas.getBoundingClientRect();  
      const x = e.clientX - rect.left;  
      const y = e.clientY - rect.top;

      // Create a random contact  
      const angle = Math.random() * Math.PI * 2;  
      contacts.push({  
        x,   
        y,   
        speed: Math.random() + 0.75, // Halved range: 0.75 to 1.75 px/frame  
        angle  
      });  
    });

    // Sonar button handler  
    document.getElementById('sonarBtn').addEventListener('click', () => {  
      playSonarPing(); // Random direction for manual ping  
      
      // Flash the screen slightly to simulate active sonar pulse  
      const flash = document.createElement('div');  
      flash.style.position = 'fixed';  
      flash.style.top = '0';  
      flash.style.left = '0';  
      flash.style.width = '100%';  
      flash.style.height = '100%';  
      flash.style.backgroundColor = 'rgba(0, 255, 0, 0.1)';  
      flash.style.pointerEvents = 'none';  
      flash.style.transition = 'opacity 0.3s';  
      document.body.appendChild(flash);  
      
      setTimeout(() => {  
        flash.style.opacity = '0';  
        setTimeout(() => {  
          document.body.removeChild(flash);  
        }, 300);  
      }, 50);  
    });  

    // Start the animation  
    animate();  
  </script>  
</body>  
</html>