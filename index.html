<!DOCTYPE html>
<html lang="en">
<head>  <meta charset="UTF-8">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Tactical Radar Sweep Demo — Authenticated Naval Ops</title>  <style>  body {  margin: 0;  padding: 20px;  background-color: #0a0a10;  color: #0f0;  font-family: 'Courier New', monospace;  display: flex;  flex-direction: column;  align-items: center;  }      h1 {  margin-bottom: 10px;  text-shadow: 0 0 5px rgba(0,255,0,0.7);  font-size: 1.8rem;  }

.console-border {  border: 4px solid #333;  border-radius: 12px;  padding: 8px;  background: #000;  box-shadow: inset 0 0 30px rgba(0,0,0,0.9), 0 0 15px rgba(0,255,0,0.1);  }      canvas {  display: block;  background-color: #0a0a10;  cursor: crosshair;  }

.status-bar {  margin-top: 15px;  font-size: 0.9rem;  color: #888;  text-align: center;  }      .controls {  display: flex;  gap: 20px;  margin-top: 15px;  align-items: center;  }

button {  background: rgba(0, 30, 0, 0.7);  border: 2px solid #0f0;  color: #0f0;  padding: 8px 20px;  font-family: 'Courier New', monospace;  font-weight: bold;  cursor: pointer;  text-transform: uppercase;  transition: all 0.1s;  }

button:hover {  background: rgba(0, 50, 0, 0.8);  box-shadow: 0 0 10px #0f0;  }

button:active {  transform: scale(0.97);  background: #0f0;  color: #000;  }  

.sonar-controls {  display: flex;  gap: 15px;  align-items: center;  margin-top: 10px;  }

.range-slider, .depth-slider {  display: flex;  flex-direction: column;  min-width: 200px;  }

.range-display, .depth-display {  font-size: 12px;  color: #8f8;  text-align: center;  }
</style>
</head>  <body>  <h1>TACTICAL RADAR SWEEP (60 FPS) — PHOSPHOR GLOW ENGINE</h1>

<div class="console-border">  <canvas id="radarCanvas" width="800" height="600"></canvas>  </div>

<div class="controls">  <button id="sonarBtn">ACTIVATE SONAR (PING)</button>  <span>Click on radar to add contacts</span>  </div>

<div class="status-bar">  FPS: <span id="fpsDisplay">60</span> | CONTACTS: <span id="contactCount">2</span> | DEPTH: 300m  </div>

<div class="sonar-controls">
  <div class="range-slider">
    <label for="rangeFilter">Range Filter (nm)</label>
    <input type="range" id="rangeFilter" min="10" max="60" value="50" step="5">
    <div class="range-display"><span id="minRangeDisplay">50</span> - <span id="maxRangeDisplay">300</span> nm</div>
  </div>
  <button id="toggleGhostBtn">GHOST ECHO: ON</button>
</div>

<div class="sonar-controls">
  <div class="depth-slider">
    <label for="depthFilter">Depth Filter (m)</label>
    <input type="range" id="depthFilter" min="0" max="500" value="300" step="10">
    <div class="depth-display"><span id="minDepthDisplay">0</span> - <span id="maxDepthDisplay">300</span> m</div>
  </div>
</div>

<script>  
// Setup canvas and context  
const canvas = document.getElementById('radarCanvas');  
const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no transparency on base      
  
// State variables  
let contacts = [  
  { x: 400, y: 150, speed: 0.75, angle: Math.PI / 4, depth: 50 }, // Friendly sub (green) — shallow depth  
  { x: 600, y: 400, speed: 0.6, angle: -Math.PI / 3, depth: 200 }  // Enemy contact (red) — deep depth  
];      
  
let blipTrails = []; // Store recent positions for trails  
const MAX_BLIP_TRAIL_LENGTH = 8; // Trail length in frames  
const SWEEP_SPEED = Math.PI / 320; // Rotation speed (~5.3s/cycle)  
let sweepAngle = 0;  
let lastTime = performance.now();  
let frameCount = 0;  
let fps = 60;

// Range filter settings (in nm, scale: 5px = 1nm)
let minRangeNm = 10;
let maxRangeNm = 300;

// Depth filter settings
let minDepthM = 0;
let maxDepthM = 300;

// Ghost echo toggle
let ghostEchoesEnabled = true;

// Audio context for sonar  
let audioCtx = null;  

function initAudio() {  
  if (!audioCtx) {    
    const AudioContext = window.AudioContext || window.webkitAudioContext;    
    audioCtx = new AudioContext();  
  }  
  if (audioCtx.state === 'suspended') {    
    audioCtx.resume();  
  }  
}  

// Play realistic sonar ping with optional bearing for spatial panning  
function playSonarPing(bearingAngle, contactSpeed) {  
  initAudio();      
  const osc = audioCtx.createOscillator();  
  const gainNode = audioCtx.createGain();      
  osc.type = 'sine';      
  // Doppler shift: pitch changes based on relative speed  
  let baseFreq = 200;
  if (typeof contactSpeed !== 'undefined' && contactSpeed > 0) {
    // Higher pitch if moving toward sweep direction, lower if away
    const dopplerFactor = 1 + (contactSpeed * 0.05); // ±5% shift max
    baseFreq *= dopplerFactor;
  }
  
  osc.frequency.setValueAtTime(baseFreq, audioCtx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);      
  
  // Create spatial effect (stereo panning)  
  const panner = audioCtx.createStereoPanner();      
  
  if (typeof bearingAngle !== 'undefined') {    
    // Map bearing to pan: North=0°, East=90°, South=180°, West=270°    
    // Pan value: -1 (left) to +1 (right), 0 = center    
    panner.pan.value = Math.sin(bearingAngle);  
  } else {    
    // Random direction if no bearing specified (for manual ping button)    
    panner.pan.value = Math.random() * 2 - 1;  
  }
  
  osc.connect(panner);  
  panner.connect(gainNode);  
  gainNode.connect(audioCtx.destination);      
  gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);  
  gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);      
  osc.start();  
  osc.stop(audioCtx.currentTime + 0.6);

  // Visual ping effect — create expanding echo ring at sweep position  
  createSonarEchoRing(sweepAngle);
}  

let sonarWaves = []; // Old-style concentric rings  
let echoRings = [];  // New: directional echo rings from contacts  
let ghostBlips = []; // Ghost echoes at previous positions

function createSonarWaveform() {  
  sonarWaves.push({    
    x: canvas.width / 2,    
    y: canvas.height / 2,    
    radius: 10,    
    opacity: 0.8  
  });
}

// Create echo ring for contact detection  
function createSonarEchoRing(sweepAngle) {  
  const centerX = canvas.width / 2;  
  const centerY = canvas.height / 2;
  
  echoRings.push({    
    x: centerX + Math.cos(sweepAngle) * (canvas.width/1.8), // Ring starts near edge    
    y: centerY + Math.sin(sweepAngle) * (canvas.width/1.8),
    radius: 5,    
    opacity: 0.6,
    maxRadius: canvas.width / 1.2
  });
}

// Add ghost blip for contact that just passed under sweep  
function addGhostBlip(contact, angleFromCenter, dist) {  
  if (!ghostEchoesEnabled) return;

  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;

  // Calculate previous position based on current movement vector
  const ghostDist = Math.max(50, dist - (contact.speed * 3)); // Slightly closer than actual
  const ghostX = centerX + Math.cos(angleFromCenter) * ghostDist;
  const ghostY = centerY + Math.sin(angleFromCenter) * ghostDist;

  ghostBlips.push({    
    x: contact.x,
    y: contact.y,
    ghostX: ghostX,
    ghostY: ghostY,
    opacity: 0.8, // Increased visibility!
    age: 0,
    maxAge: 15 // Fade out after ~15 frames
  });
}

// Draw ocean background with "depth illusion"  
function drawBackground() {  
  // Deep ocean gradient  
  const bgGradient = ctx.createRadialGradient(    
    canvas.width/2, canvas.height/2, 0,    
    canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)/1.5  
  );  
  bgGradient.addColorStop(0, "#0a1a2a");  
  bgGradient.addColorStop(1, "#000000");      
  
  ctx.fillStyle = bgGradient;  
  ctx.fillRect(0, 0, canvas.width, canvas.height);      
  
  // Subtle seabed noise (sparse dots)  
  const noiseSize = Math.floor(canvas.width * canvas.height / 500);  
  for (let i = 0; i < noiseSize; i++) {    
    if (i % 3 === 0) { // Only draw ~1/3 of potential dots to keep it sparse      
      ctx.fillStyle = `rgba(0, 30, 60, ${Math.random() * 0.1})`;      
      const x = Math.random() * canvas.width;      
      const y = Math.random() * canvas.height;      
      ctx.fillRect(x, y, 2, 2);    
    }  
  }

  // Grid lines (subtle tactical overlay)  
  ctx.strokeStyle = "rgba(0, 255, 64, 0.1)";  
  ctx.lineWidth = 1;      
  
  const gridSize = 100;  
  ctx.beginPath();  
  for (let x = 0; x <= canvas.width; x += gridSize) {    
    ctx.moveTo(x, 0);    
    ctx.lineTo(x, canvas.height);  
  }  
  for (let y = 0; y <= canvas.height; y += gridSize) {    
    ctx.moveTo(0, y);    
    ctx.lineTo(canvas.width, y);  
  }  
  ctx.stroke();

  // Depth rings (depth filter visualization)
  const maxRadius = Math.hypot(canvas.width/2, canvas.height/2);
  const depthScale = maxRadius / 500; // 500m maps to max radius
  
  for (let depth = 100; depth <= 400; depth += 100) {
    if (depth >= minDepthM && depth <= maxDepthM) {
      const r = depth * depthScale;
      ctx.strokeStyle = `rgba(0, 255, 255, ${0.1 + (depth/1000)})`;
      ctx.beginPath();
      ctx.arc(canvas.width/2, canvas.height/2, r, 0, Math.PI * 2);
      ctx.stroke();
      
      // Depth label
      ctx.fillStyle = "rgba(0, 255, 255, 0.3)";
      ctx.font = "10px monospace";
      ctx.textAlign = "center";
      ctx.fillText(`${depth}m`, canvas.width/2 + r - 15, canvas.height/2);
    }
  }

  // Crosshair at center  
  ctx.strokeStyle = "rgba(0, 255, 64, 0.3)";  
  ctx.beginPath();  
  ctx.arc(canvas.width/2, canvas.height/2, 100, 0, Math.PI * 2);  
  ctx.stroke();
}  

// Draw contacts (blips) with trails and authentic radar behavior  
function drawContacts() {  
  const centerX = canvas.width / 2;  
  const centerY = canvas.height / 2;

  // Sweep bounds for this frame  
  const trailLength = Math.PI / 6; // 30° trail  
  let sweepStartAngle = sweepAngle - trailLength;
  let sweepEndAngle = sweepAngle;

  contacts.forEach((contact, i) => {    
    // Initialize properties if not present (FIXED: check both properties independently)    
    contact.lastInSweep = (typeof contact.lastInSweep === 'undefined') ? false : contact.lastInSweep;    
    contact.undetectedFrames = (typeof contact.undetectedFrames === 'undefined') ? 0 : contact.undetectedFrames;
    // Initialize depth if not present
    contact.depth = (typeof contact.depth === 'undefined') ? 150 : contact.depth;

    // Record current position for trail    
    if (!contact.trail) contact.trail = [];    
    contact.trail.push({ x: contact.x, y: contact.y });    
    if (contact.trail.length > MAX_BLIP_TRAIL_LENGTH) contact.trail.shift();

    // Move contact    
    contact.x += Math.cos(contact.angle) * contact.speed;    
    contact.y += Math.sin(contact.angle) * contact.speed;        
    // Wrap around screen edges (toroidal space)    
    if (contact.x < 0) contact.x = canvas.width;    
    if (contact.x > canvas.width) contact.x = 0;    
    if (contact.y < 0) contact.y = canvas.height;    
    if (contact.y > canvas.height) contact.y = 0;

    // Draw trail    
    for (let j = 0; j < contact.trail.length; j++) {      
      const pos = contact.trail[j];      
      const alpha = (j / contact.trail.length) * 0.4; // Fade from center to end            
      
      ctx.fillStyle = i === 0 ? `rgba(0,255,0,${alpha})` : `rgba(255,0,0,${alpha})`;      
      ctx.beginPath();      
      ctx.arc(pos.x, pos.y, 2, 0, Math.PI * 2);      
      ctx.fill();    
    }

    // Calculate distance from center (in pixels)    
    const dx = contact.x - centerX;    
    const dy = contact.y - centerY;    
    const distPx = Math.sqrt(dx*dx + dy*dy);
    const distNm = distPx / 5; // Scale: 5px = 1nm

    // Range filter check    
    if (distNm < minRangeNm || distNm > maxRangeNm) {      
      return; // Skip contacts outside range filter    
    }

    // Depth filter check
    const contactDepth = contact.depth;
    if (contactDepth < minDepthM || contactDepth > maxDepthM) {
      return; // Skip contacts outside depth filter
    }

    // Calculate bearing (angle from center)    
    let angleFromCenter = Math.atan2(dy, dx);    
    if (angleFromCenter < 0) angleFromCenter += Math.PI * 2;

    // Determine if contact is within current sweep arc — FIXED to match actual sweep bounds    
    let inSweep = false;        
    // Normalize sweep angles to [0, 2π)    
    while (sweepStartAngle < 0) sweepStartAngle += Math.PI * 2;
    while (sweepEndAngle > Math.PI * 2) sweepEndAngle -= Math.PI * 2;

    if (sweepStartAngle <= sweepEndAngle) {      
      // Normal arc (no wrap around 0°)      
      inSweep = angleFromCenter >= sweepStartAngle && angleFromCenter <= sweepEndAngle;    
    } else {      
      // Arc crosses 0° boundary — split into two ranges      
      inSweep = angleFromCenter >= sweepStartAngle || angleFromCenter <= sweepEndAngle;    
    }

    // Sonar ping only when sweep *first* reaches contact (transition from !inSweep to inSweep)    
    if (!contact.lastInSweep && inSweep) {      
      // Convert radar bearing to pan value for spatial audio      
      const bearingFromNorth = (Math.PI / 2 - angleFromCenter + Math.PI * 2) % (Math.PI * 2);
      
      // Add ghost blip when contact is first detected
      addGhostBlip(contact, angleFromCenter, distPx);
      
      playSonarPing(bearingFromNorth, contact.speed);
    }

    // Update lastInSweep state    
    contact.lastInSweep = inSweep;

    // Handle fade-out if not detected for several sweeps    
    if (!inSweep) {      
      contact.undetectedFrames++;    
    } else {      
      contact.undetectedFrames = 0;    
    }

    // Calculate signal strength based on proximity to sweep center (0=strong, 1=weak)    
    const angleDiff1 = Math.abs(angleFromCenter - sweepAngle);    
    const angleDiff2 = Math.abs(angleFromCenter - (sweepAngle + Math.PI * 2));    
    const angleDiff3 = Math.abs((angleFromCenter + Math.PI * 2) - sweepAngle);    
    const minAngleDiff = Math.min(angleDiff1, angleDiff2, angleDiff3);
    // Normalize: 0 at center of sweep, 1 at edges
    const signalStrength = Math.min(minAngleDiff / (trailLength/2), 1);

    // Fade out if undetected for too long    
    let contactAlpha = 1;    
    if (contact.undetectedFrames > 5) {      
      contactAlpha = Math.max(0, 1 - (contact.undetectedFrames - 5) * 0.2);    
    }

    // Draw contact blip with signal strength and fade      
    ctx.shadowBlur = inSweep ? 8 : 0;  
    ctx.shadowColor = i === 0 ? "#0f0" : "#f00";  
        
    const baseColor = i === 0 ? "rgba(0,255,0," : "rgba(255,0,0,";
    // Signal strength affects glow: stronger when closer to sweep center
    ctx.fillStyle = baseColor + (contactAlpha * (1 - signalStrength * 0.3)) + ")"; 
    
    // Contact size varies slightly with signal strength
    const blipSize = inSweep ? 4 : Math.max(2, 3 - signalStrength);
    
    ctx.beginPath();  
    ctx.arc(contact.x, contact.y, blipSize, 0, Math.PI * 2);  
    ctx.fill();

    // Label (distance and bearing) — only show when under sweep or friendly    
    if (inSweep || i === 0) {      
      ctx.fillStyle = `rgba(143, 255, 136, ${contactAlpha})`;      
      ctx.font = "10px monospace";      
      const rangeNm = Math.round(distPx / 5);      
      const bearingDeg = Math.round(angleFromCenter * (180/Math.PI));          
      
      // Add depth info to label
      const depthInfo = contactDepth > 0 ? ` D:${contactDepth}m` : '';
      ctx.fillText(`BLIP-${i+1} R:${rangeNm}nm B:${bearingDeg}${depthInfo}`, contact.x + 10, contact.y - 8);    
    }

    ctx.shadowBlur = 0;  
  });      
  
  // Draw ghost blips (delayed echoes) — CLEANED UP TEXT!
  for (let i = ghostBlips.length - 1; i >= 0; i--) {    
    const ghost = ghostBlips[i];        
    ghost.age++;    
    ghost.opacity -= 0.04;
    
    if (ghost.opacity <= 0 || ghost.age > ghost.maxAge) {      
      ghostBlips.splice(i, 1);      
      continue;    
    }
    
    // Draw ghost blip at previous position — BRIGHTER!
    ctx.fillStyle = `rgba(255, 255, 255, ${ghost.opacity})`; // Was *0.4
    ctx.beginPath();
    ctx.arc(ghost.x, ghost.y, 4, 0, Math.PI * 2); // Larger size: was 3
    ctx.fill();
    
    // Draw line connecting to actual position — THICKER!
    ctx.strokeStyle = `rgba(255, 255, 255, ${ghost.opacity})`; // Was *0.2
    ctx.lineWidth = 2; // Was 1
    ctx.beginPath();
    ctx.moveTo(ghost.x, ghost.y);
    ctx.lineTo(ghost.ghostX, ghost.ghostY);
    ctx.stroke();
    
    // REMOVED: Ghost text labels to prevent visual "glitching"
    // Ghost echoes are visual aids — no need for detailed labels that clutter the display
  }
}  

// Draw radar sweep — single wedge with gradient and sharp leading edge  
function drawRadarSweep() {  
  const centerX = canvas.width / 2;  
  const centerY = canvas.height / 2;  
  const radius = Math.hypot(centerX, centerY); // Half-diagonal → reaches all corners  

  ctx.globalCompositeOperation = 'lighter';

  // Single sweep wedge — shorter trail for sharper look  
  const trailLength = Math.PI / 6; // 30° trail (was 60°)  
  let startAngle = sweepAngle - trailLength;
  const endAngle = sweepAngle;

  if (startAngle < 0) {    
    // Arc crosses top — draw in two parts    
    ctx.beginPath();    
    ctx.moveTo(centerX, centerY);    
    ctx.arc(centerX, centerY, radius, startAngle + Math.PI * 2, Math.PI * 2);    
    ctx.arc(centerX, centerY, radius, 0, endAngle);  
  } else if (endAngle > Math.PI * 2) {    
    // Arc crosses bottom — draw in two parts    
    ctx.beginPath();    
    ctx.moveTo(centerX, centerY);    
    ctx.arc(centerX, centerY, radius, startAngle, Math.PI * 2);    
    ctx.arc(centerX, centerY, radius, 0, endAngle - Math.PI * 2);  
  } else {    
    // Normal arc (no wrap)    
    ctx.beginPath();    
    ctx.moveTo(centerX, centerY);    
    ctx.arc(centerX, centerY, radius, startAngle, endAngle);  
  }
  
  ctx.closePath();

  // Radial gradient for glow falloff  
  const grad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
  grad.addColorStop(0, 'rgba(0, 255, 0, 0)');     // transparent at center  
  grad.addColorStop(0.3, 'rgba(0, 255, 0, 0.15)'); // mid-fade  
  grad.addColorStop(1, 'rgba(0, 255, 0, 0.25)');   // faint edge  

  ctx.fillStyle = grad;  
  ctx.fill();

  // Bright leading edge line with optimized glow  
  ctx.beginPath();  
  ctx.moveTo(centerX, centerY);  
  ctx.lineTo(    
    centerX + Math.cos(sweepAngle) * radius,    
    centerY + Math.sin(sweepAngle) * radius  
  );  
  ctx.strokeStyle = 'rgba(0, 255, 100, 1.0)'; // Brighter line (was 0.9)
  ctx.lineWidth = 2;
  ctx.shadowBlur = 8; // Reduced from 12 for tighter glow  
  ctx.shadowColor = '#0f0';
  ctx.stroke();
  ctx.shadowBlur = 0;

  ctx.globalCompositeOperation = 'source-over';

  // Update sweep angle for next frame  
  sweepAngle += SWEEP_SPEED;  
  if (sweepAngle >= Math.PI * 2) {    
    sweepAngle -= Math.PI * 2;  
  }

  // Draw sonar waveforms if active  
  for (let i = sonarWaves.length - 1; i >= 0; i--) {    
    const wave = sonarWaves[i];        
    // Expand and fade    
    wave.radius += 3;    
    wave.opacity -= 0.02;

    if (wave.opacity <= 0) {      
      sonarWaves.splice(i, 1);      
      continue;    
    }

    ctx.beginPath();    
    ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);    
    ctx.strokeStyle = `rgba(0, 255, 255, ${wave.opacity})`;    
    ctx.lineWidth = 2;    
    ctx.stroke();

    // Add "ping" text at interval    
    if (Math.floor(Date.now() / 100) % 3 === 0) {      
      ctx.fillStyle = `rgba(255, 255, 255, ${wave.opacity})`;      
      ctx.font = "bold 14px monospace";      
      ctx.fillText("PING!", wave.x - 18, wave.y + 4);    
    }  
  }

  // Draw echo rings from contact detections  
  for (let i = echoRings.length - 1; i >= 0; i--) {    
    const ring = echoRings[i];    
    // Expand and fade    
    ring.radius += 8;
    ring.opacity -= 0.05;

    if (ring.opacity <= 0 || ring.radius > ring.maxRadius) {      
      echoRings.splice(i, 1);      
      continue;    
    }

    ctx.beginPath();
    ctx.arc(ring.x, ring.y, ring.radius, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(0, 255, 255, ${ring.opacity})`;
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Add echo indicator text    
    if (Math.floor(Date.now() / 50) % 4 === 0) {      
      ctx.fillStyle = `rgba(255, 255, 255, ${ring.opacity})`;      
      ctx.font = "10px monospace";      
      const rangeNm = Math.round(ring.radius / 8); // Approximate scale
      ctx.fillText(`ECHO ${rangeNm}nm`, ring.x - 15, ring.y + 3);    
    }  
  }

  // Draw center hub  
  ctx.fillStyle = "#0a3a0a";  
  ctx.beginPath();  
  ctx.arc(centerX, centerY, 25, 0, Math.PI * 2);  
  ctx.fill();

  // Crosshair lines  
  ctx.strokeStyle = "rgba(0, 255, 64, 0.3)";  
  ctx.lineWidth = 1;  
  ctx.beginPath();  
  ctx.moveTo(centerX - 30, centerY);  
  ctx.lineTo(centerX + 30, centerY);  
  ctx.moveTo(centerX, centerY - 30);  
  ctx.lineTo(centerX, centerY + 30);  
  ctx.stroke();

  // Range rings with labels (nautical miles)  
  for (let r = 150; r < radius; r += 150) {    
    const nm = Math.round(r / 5); // Scale: 5px = 1nm      
    
    ctx.strokeStyle = "rgba(0, 255, 64, 0.15)";  
    ctx.beginPath();  
    ctx.arc(centerX, centerY, r, 0, Math.PI * 2);  
    ctx.stroke();

    // Label on the ring  
    ctx.fillStyle = "#8f8";  
    ctx.font = "bold 12px monospace";  
    ctx.textAlign = "center";  
    ctx.fillText(`${nm}nm`, centerX + r - 15, centerY - 3);  
  }

  // Direction indicator (N)  
  ctx.fillStyle = "#8f8";  
  ctx.font = "bold 14px monospace";  
  ctx.textAlign = "left";  
  ctx.fillText("N", centerX + 5, centerY - radius + 15);
}  

// Main render loop  
function animate() {  
  const now = performance.now();  
  frameCount++;      
  
  if (now - lastTime >= 1000) {    
    fps = Math.round((frameCount * 1000) / (now - lastTime));    
    document.getElementById('fpsDisplay').innerText = fps;        
    // Update contact count    
    document.getElementById('contactCount').innerText = contacts.length;        
    frameCount = 0;    
    lastTime = now;  
  }

  // Clear canvas with slight fade for motion blur effect  
  ctx.fillStyle = "rgba(10, 26, 42, 0.3)"; // Very slight trail  
  ctx.fillRect(0, 0, canvas.width, canvas.height);      
  
  drawBackground();  
  drawContacts();  
  drawRadarSweep();

  requestAnimationFrame(animate);
}

// Click to add new contacts (e.g., detected by sonar)  
canvas.addEventListener('click', (e) => {  
  const rect = canvas.getBoundingClientRect();  
  const x = e.clientX - rect.left;  
  const y = e.clientY - rect.top;

  // Create a random contact with random depth
  const angle = Math.random() * Math.PI * 2;
  const depth = Math.floor(Math.random() * 400) + 50; // 50-450m
  
  contacts.push({    
    x,    
    y,    
    speed: Math.random() + 0.75, // Halved range: 0.75 to 1.75 px/frame
    angle,
    depth  
  });
});

// Sonar button handler  
document.getElementById('sonarBtn').addEventListener('click', () => {  
  playSonarPing(); // Random direction for manual ping      
  // Flash the screen slightly to simulate active sonar pulse  
  const flash = document.createElement('div');  
  flash.style.position = 'fixed';  
  flash.style.top = '0';  
  flash.style.left = '0';  
  flash.style.width = '100%';  
  flash.style.height = '100%';  
  flash.style.backgroundColor = 'rgba(0, 255, 0, 0.1)';  
  flash.style.pointerEvents = 'none';  
  flash.style.transition = 'opacity 0.3s';  
  document.body.appendChild(flash);      
  
  setTimeout(() => {    
    flash.style.opacity = '0';    
    setTimeout(() => {      
      document.body.removeChild(flash);    
    }, 300);  
  }, 50);
});

// Range filter slider handler
const rangeSlider = document.getElementById('rangeFilter');
const minRangeDisplay = document.getElementById('minRangeDisplay');
const maxRangeDisplay = document.getElementById('maxRangeDisplay');

rangeSlider.addEventListener('input', () => {
  const value = parseInt(rangeSlider.value);
  minRangeNm = value;
  maxRangeNm = value * 6; // Max range is 6x the min (50-300nm at default)
  
  minRangeDisplay.textContent = minRangeNm;
  maxRangeDisplay.textContent = maxRangeNm;
});

// Depth filter slider handler
const depthSlider = document.getElementById('depthFilter');
const minDepthDisplay = document.getElementById('minDepthDisplay');
const maxDepthDisplay = document.getElementById('maxDepthDisplay');

depthSlider.addEventListener('input', () => {
  const value = parseInt(depthSlider.value);
  minDepthM = 0;
  maxDepthM = value; // Filter shows contacts shallower than this depth
  
  minDepthDisplay.textContent = minDepthM;
  maxDepthDisplay.textContent = maxDepthM;
});

// Ghost echo toggle button — ENHANCED VISUAL FEEDBACK!
const ghostBtn = document.getElementById('toggleGhostBtn');
    
ghostBtn.addEventListener('click', () => {
  ghostEchoesEnabled = !ghostEchoesEnabled;
  ghostBtn.textContent = `GHOST ECHO: ${ghostEchoesEnabled ? 'ON' : 'OFF'}`;
  
  if (!ghostEchoesEnabled) {
    // Clear existing ghosts and show confirmation
    ghostBlips = [];
    console.log("Ghost echoes OFF — cleared");
  } else {
    // Spawn a test ghost to prove it's working!
    const testContact = { x: canvas.width/2 + 100, y: canvas.height/2, speed: 0.75, angle: Math.PI/4 };
    addGhostBlip(testContact, Math.PI/4, Math.hypot(100, 0));
    console.log("Ghost echoes ON — test ghost spawned");
  }
  
  // Visual button feedback
  ghostBtn.style.background = `rgba(${ghostEchoesEnabled ? '0,50,0' : '50,0,0'}, 0.8)`;
  setTimeout(() => {
    ghostBtn.style.background = "rgba(0, 30, 0, 0.7)";
  }, 100);
});

// Start the animation  
animate();  
</script>  </body>
</html>
